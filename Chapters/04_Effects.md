# Effects

A pure function accepts arguments and produces a result.
Nothing more.
Because of this we can combine pure functions and the result will also be a pure function.
Pure functions are basically mathematical functions, and so obey the laws of math.
This means we can reason about pure functions in a mathematical manner.

For example, identical arguments produce the same result every time.
It's as if a pure function is only a lookup table.

Because of all the benefits of pure functions, we clearly want to use them everywhere we can.
A program composed of pure functions would be very reliable indeed.
It would also have no interactions with the outside world, neither reading from nor writing to.
A program comprised solely of pure functions has no *effect* upon the world.
Without that, the only evidence that you ran the program is the additional warmth generated by your computer.

A program that does interact with the world introduces a lot of uncertainty.
In particular, the world is a completely uncertain state, as far as the program is concerned.
The output effects of the program depend on the input effects when the program runs.
No longer are identical inputs producing the same result, every time. {{???}}

With the addition of all this uncertainty, errors become a serious possibility.
Errors also have an affect on the world (if they do not there is no point to their existence).

The problem is this: functions that affect or are affected by the world do so by directly contacting the world.
In the previous chapter we solved the problem of needing to return extra information by boxing all necessary information into the function's result value, as a monad.
In this chapter we solve the problem of effects by boxing further information into the result monad.
Doing so captures the effects so we can keep an eye on them.
We write as many pure functions as possible, and when we need to do something effect-full, we isolate that in its own function, and limit the spread of uncertainty.
The result is not deterministic, but we have isolated the effects.
This allows us to much more effectively reason about the behavior of our program.

## Basics

Consider a function that affects its surroundings:

```scala mdoc
object X:
  var x: Int = 0

def combine(a: Int, b: Int): Int =
  X.x += 1
  a + b + X.x

combine(1, 2)
combine(1, 2)
```

Because `combine` both writes to and reads from the global variable `X.x`, identical arguments will *not* produce the same result every time.
`combine` affects the surrounding value of `X.x` and also depends on it to produce its result.
`combine` is not pure.

We want to manage this effect `X`.
We'll repeat the trick we used in [Monads] but this time, instead of packaging the return value with failure information, we'll package it with the type `X`:

```scala
trait XIO[IO, R]

object IntXIO extends XIO[X, Int]:
  def apply(i: Int): XIO[X, Int] = this

def combine2(a: Int, b: Int): XIO[X, Int] =
  X.x += 1
  IntXIO(a + b + X.x)
```
